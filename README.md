# Git Learning Journey - Complete Notes

## Quick Access
üìã [Git & GitHub Cheatsheet](git_cheatsheet.md) - Essential commands and code snippets


## Course Learning Plan Schedule

### ‚úÖ Course 1: Introduction to Git (Beginner) - **COMPLETED**
### ‚úÖ Course 2: Intermediate Git (Beginner) - **COMPLETED**
### ‚úÖ Course 3: Introduction to GitHub Concepts (Beginner) - **COMPLETED**
### ‚úÖ Course 4: Intermediate GitHub Concepts (Beginner) - **COMPLETED**  
### ‚úÖ  Course 5: Advanced Git (Advanced) - **COMPLETED**

---

## Course 1: Introduction to Git (Beginner) ‚úÖ

### Chapter 01: Getting Started with Git

#### Essential Terminal Commands
```bash
pwd                    # Print working directory
ls                     # List directory contents
cd directory-name      # Change directory
```

#### Git Setup and Basic Operations
```bash
git --version                        # Check Git version
git init directory-name              # Create new repo with directory
git init                            # Convert existing project to repo
git status                          # Check what files are being tracked
```

#### Staging and Committing
```bash
git add README.md                   # Add specific file to staging area
git add .                          # Add all modified files to staging area
git commit -m "Adding a README."   # Make commit with message (-m flag avoids opening text editor)
```

### Chapter 02: Understanding Git Structure and History

#### Git Internal Structure
- **Commit**: Snapshot of your project at a specific point in time
- **Tree**: Directory structure and file organization
- **Blob**: Binary Large Object (stores file content)
- **Git Hash**: Pseudo-random number generated by hash function for unique identification

#### Viewing Commit History
```bash
git log                                    # View full commit history
git log -3                                # Show last 3 commits
git log report.md                         # Show commits for specific file
git log -2 mental_health_survey.csv      # Combine techniques: last 2 commits for specific file
```

**Navigation in git log:**
- Press `Space` to show more recent commits
- Press `q` to quit log and return to terminal

#### Filtering by Date Range
```bash
git log --since='Apr 2 2024'                           # Commits since specific date
git log --since='Apr 2 2024' --until='Apr 11 2024'    # Commits between dates
```

**Acceptable Date Formats:**
- Natural language: "2 weeks ago", "3 months ago", "yesterday"
- ISO Format (recommended): "2024-07-15" (YYYY-MM-DD)
- Alternative formats: "15 Jul 2024", "15 July 2024"
- ‚ö†Ô∏è Invalid: "15 Jul, 2024"
- ‚ö†Ô∏è Ambiguous: "12-06-2024" (could be Dec 6 or June 12)

#### Examining Specific Commits
```bash
git show c27fa856    # Show specific commit (first 8-10 characters of hash sufficient)
```

#### Comparing Versions
```bash
# Basic comparisons
git diff                    # Compare working directory with last commit
git diff report.md         # Compare specific file

# Staged file comparisons
git add report.md
git diff --staged report.md    # Compare staged file with last commit
git diff --staged             # Compare all staged files

# Commit comparisons
git diff 35f4b4d 186398f     # Compare two specific commits
git diff HEAD~1 HEAD         # Compare second most recent with most recent
git diff HEAD~1 HEAD~2       # Compare using HEAD notation
```

#### Restoring and Reverting

**Reverting Commits:**
```bash
git revert HEAD                # Revert most recent commit
git revert --no-edit HEAD     # Revert without opening text editor
git revert -n HEAD            # Revert without committing (stage changes only)
```

**Text Editor Commands (for commit messages):**
- Save: `Ctrl + O`, then `Enter`
- Exit: `Ctrl + X`

**Reverting Single Files:**
```bash
git checkout HEAD~1 -- report.md    # Revert specific file to previous commit
git status                          # Check status after checkout
```

**Unstaging Files:**
```bash
git restore --staged summary_statistics.csv    # Unstage specific file
git restore --staged                           # Unstage all files
```

---

## Course 2: Intermediate Git (Beginner) ‚úÖ

### Chapter 01: Introduction to Branches

#### Understanding Branches
- **Branch**: An individual version of a repository
- Git uses branches to systematically track multiple versions of files
- In each branch:
  - Some files might be the same
  - Others might be different  
  - Some may not exist at all

#### Why Use Branches?
- **Live System Protection**: Default branch (`main`) works as expected
- **Feature Development**: Develop new features without affecting live system
- **Parallel Development**: Multiple developers can work simultaneously
- **Comparison**: Compare repo state between branches
- **Integration**: Combine contents and push new features to live system
- **Purpose-Driven**: Each branch should have a specific purpose

#### Working with Branches
```bash
# List all branches
git branch                    # Shows all branches (* indicates current branch)

# Switch between branches
git switch main              # Switch to main branch

# Create new branch
git branch speed-test        # Create new branch
git switch speed-test        # Switch to new branch
git switch -c speed-test     # Create and switch in one command
```

#### Branch Terminology
- **Branching off**: Creating a new branch
- **Branching off main**: Creating a new branch from main branch

### Chapter 02: Working with Branches (Modifying, Comparing, Merging, Conflicts, Remotes)

#### Diff Recap
```bash
git diff                            # Changes between unstaged files and latest commit
git diff report.md                  # Changes between unstaged file and latest commit
git diff --staged                   # Changes between staged files and latest commit
git diff --staged report.md         # Changes between staged file and latest commit
git diff 35f4b4d 186398f            # Changes between two commits using hashes
git diff HEAD~1 HEAD~2              # Changes between commits using HEAD notation
```

#### Comparing Branches
```bash
git diff main summary-statistics     # Compare main branch with summary-statistics branch
```

**Navigation**: Press `Space` to progress through large outputs, `q` to exit

#### Branch Management
```bash
# Rename branch
git branch -m feature_dev chatbot   # Rename feature_dev to chatbot

# Delete merged branch
git branch -d chatbot               # Delete branch that has been merged
# Output: Deleted branch chatbot (was 3edb989).

# Delete unmerged branch (force delete)
git branch -D chatbot               # Force delete unmerged branch
```

**‚ö†Ô∏è Important**: Difficult to recover deleted branches - be sure before deleting!

#### Merging Branches
- **Purpose**: Each branch should have a specific purpose (new feature, debugging)
- **Integration**: Incorporate changes into production (main branch = "ground truth")
- **Terminology**:
  - **Parent commits**: Last commits from each branch being merged
  - **Source**: Branch we want to merge from
  - **Destination**: Branch we want to merge into

```bash
# Basic merge workflow
git switch main                     # Move to destination branch
git merge ai-assistant             # Merge source branch into current branch

# Alternative syntax
git merge ai-assistant main        # Merge from any branch
```

**Merge Types**:
- **Fast-forward**: Linear commit history, points main to last commit in source branch
- **Three-way merge**: When branches have diverged

#### Merge Conflicts
- **Conflict**: Inability to resolve differences in file contents between branches
- **Cause**: Same file edited in two branches, Git doesn't know which version to keep

**Conflict Resolution Process**:
```bash
# When conflict occurs
git merge documentation
# Output: Auto-merging README.md
#         CONFLICT (add/add): Merge conflict in README.md
#         Automatic merge failed; fix conflicts and then commit the result.

# Open conflicted file
nano README.md
```

**Git Conflict Syntax**:
```
<<<<<<< HEAD
Content from current branch
=======
Content from branch being merged
>>>>>>> branch-name
```

**Resolution Steps**:
1. Edit file to resolve conflicts
2. Remove conflict markers
3. Save (`Ctrl + O`, then `Enter`) and exit (`Ctrl + X`)
4. Complete merge:
```bash
git add README.md
git commit -m "Resolving README.md conflict"
git merge documentation              # Should show "Already up to date."
```

#### Working with Remotes
- **Local repo**: Repository on your local computer
- **Remote repo**: Repository stored elsewhere (usually online)

**Benefits of Remote Repos**:
- Everything is backed up
- Collaboration regardless of location

**Cloning Repositories**:
```bash
# Clone local project
git clone /home/george/repo
git clone /home/george/repo new_repo    # Clone and rename

# Clone remote repository
git clone https://github.com/datacamp/project
```

**Remote Operations**:
```bash
# List remotes
git remote                          # Shows remote names
git remote -v                       # Shows remote URLs

# Add new remote
git remote add george https://github.com/george_datacamp/repo
```

**Note**: When cloning, Git automatically names the remote `origin`

#### Pulling from Remotes
- **Fetch**: Download remote content without merging
- **Pull**: Fetch and merge in one command

```bash
# Fetch operations
git fetch origin                    # Fetch all remote branches
git fetch origin main              # Fetch only main branch

# Merge remote content
git merge origin                    # Merge origin's main into current branch

# Pull (fetch + merge)
git pull origin                     # Pull from origin's default branch
git pull origin dev                 # Pull from origin's dev branch
```

**‚ö†Ô∏è Important**: Always commit local changes before pulling!

#### Pushing to Remotes
```bash
# Basic push
git push origin main               # Push main branch to origin remote

# Push new local branch to remote
git push origin hotfix             # Creates hotfix branch on remote
```

**Push/Pull Best Practices**:
1. Save changes locally first
2. Pull before pushing to avoid conflicts
3. Handle conflicts locally before pushing

**Avoiding Conflicts**:
```bash
git pull origin main               # Pull latest changes first
git push origin main               # Then push your changes

# Pull without opening editor (use with caution)
git pull --no-edit origin main
```

---

## Course 3: Introduction to GitHub Concepts (Beginner) ‚úÖ

### Chapter 01: What is GitHub?

#### Understanding GitHub
- **GitHub**: Cloud-based hosting service that allows users to store and track their work (version control)
- **On-demand resources**: Storage over the internet - no need to store large files locally
- **Similar platforms**: GitLab, BitBucket

#### GitHub Uses
- Storing projects
- Keeping track of projects and files
- Collaborating with others
- Social networking for developers
- Open-source project hosting

#### GitHub vs. Git
- **GitHub**: 
  - Enhances Git functionality
  - Makes project management and collaboration easier
  - Cannot be used without Git
- **Git**: 
  - Version control software
  - Can be used without GitHub or other hosting platforms
  - Core technology that GitHub builds upon

#### GitHub Repository (Repo)
- Contains all files of a project
- Records past versions of files
- Provides complete history of every project stage
- Enables collaboration where several people can work on the same file
- Can be accessed by anyone (for public repos)

#### Setting Up a Repository
**Creating a New Repository:**
- Navigate to GitHub website
- Click "New" or "Create repository"
- Choose repository name
- Select public or private
- Initialize with README (optional)
- Add .gitignore (optional)
- Choose license (optional)

**Repository Navigation:**
- Files tab: View all repository files
- Code tab: Browse source code
- Issues tab: Track bugs and feature requests
- Pull requests tab: Manage code contributions
- Actions tab: Automated workflows
- Settings tab: Repository configuration

#### Creating and Formatting README
**README Purpose:**
- Must be descriptive so anyone can understand the project
- Should list repository contents
- Clearly explains the project to others

**README Fundamentals:**
- **Title**: Clear project name
- **Description of technology**: What tools/languages are used
- **Why**: Purpose and motivation
- **Description of the process**: How it works
- **Table of contents**: For larger projects

**README Extras:**
- How the project came about
- The motivation behind it
- Limitations and challenges
- What problem it hopes to solve
- Intended use cases
- Credits and acknowledgments

**Markdown Formatting:**
```markdown
# Heading 1
## Heading 2
### Heading 3

**Bold text**
*Italic text*

[Link text](https://example.com)

![Image description](image-url)
```

**Edit vs. Preview:**
- Edit tab: Write markdown
- Preview tab: See formatted output

### Chapter 02: Repository Management and Collaboration

#### Modifying Repository Structure
**Creating New Files:**
- Click "Create new file" in repository
- Name the file with appropriate extension
- Add content in the editor
- Scroll down to commit section
- Add commit message
- Choose "Commit directly to main branch" or "Create new branch"

**Uploading Files:**
- Click "Upload files" in repository
- Drag and drop files or choose files
- Add commit message
- Commit changes

**Creating New Directories:**
- When creating a file, include directory name: `folder-name/file-name.ext`
- Directory is automatically created

**Modifying Files:**
- Click on file name to view
- Click pencil icon to edit
- Make changes
- Commit with descriptive message

**Deleting Files:**
- Navigate to file
- Click trash/delete icon
- Confirm deletion
- Commit changes

#### Working with Branches
**Purpose of Branches:**
- Enable concurrent work on different parts of a project
- Help reduce risk of conflicting file versions
- Allow experimentation without affecting main code

**Main Branch:**
- Default branch in repository
- Usually contains stable, production-ready code
- Protected from direct changes in professional settings

**Creating New Branches:**
- Click branch dropdown (usually shows "main")
- Type new branch name
- Click "Create branch" or press Enter
- New branch is created from current branch

**Branch Operations:**
```bash
# List all branches (shows current branch with *)
git branch

# Switch between branches
git switch branch-name
git switch main

# Create and switch to new branch
git switch -c new-branch-name
```

**Adding Files to Branches:**
- Switch to desired branch
- Add/modify files as normal
- Changes only affect current branch

**Comparing Branches:**
- Navigate to repository main page
- Click "Compare" or use branch dropdown
- Select branches to compare
- View differences between branches

#### Branch Protection Rules
**Purpose:**
- Set rules for specific branches
- Ensure code quality and review processes
- Prevent accidental changes to important branches

**Common Protection Rules:**
- **Require pull request before merging**: No direct commits to protected branch
- **Require pull request approval**: Changes must be reviewed and approved
- **Restrict who can delete**: Prevent accidental branch deletion

**Setting Up Protection Rules:**
1. Go to Settings > Branches
2. Click "Add rule" or "Add branch protection rule"
3. Specify branch name pattern
4. Select desired protection options
5. Save changes

#### Repository Access Control
**Why Restrict Access?**
- Datasets with personally identifiable information (PII)
- Commercial or proprietary products
- Sensitive business information
- Compliance requirements

**Private vs. Public Repositories:**
- **Public**: Anyone can view and fork
- **Private**: Only collaborators can access

**Creating Private Repository:**
- During repo creation, select "Private"
- For existing repo: Settings > General > Danger Zone > Change visibility

**Managing Collaborators:**
1. Go to Settings > Manage access
2. Click "Invite a collaborator"
3. Enter username, full name, or email
4. Send invitation
5. Collaborator receives email to accept

**Collaboration Permissions:**
- **Read**: View and download
- **Write**: Read + push changes
- **Admin**: Write + manage settings

#### Personal Access Tokens (PAT)
**Why PATs are Needed:**
- GitHub removed password authentication for Git operations (August 2021)
- More secure than passwords
- Required for terminal/command line access to repositories
- Not needed for GitHub web interface

**Authentication Error Example:**
```bash
git clone https://github.com/user/repo
Username for 'https://github.com': username
Password for 'https://username@github.com': 
remote: Support for password authentication was removed on August 13, 2021.
```

**Creating a PAT:**
1. Go to GitHub Settings (profile menu)
2. Click "Developer settings" (bottom left)
3. Click "Personal access tokens" > "Tokens (classic)"
4. Click "Generate new token"
5. Add note describing token purpose
6. Set expiration date
7. Select scopes (permissions needed)
8. Click "Generate token"
9. **Copy token immediately** (won't be shown again)

**Using PAT:**
```bash
git clone https://github.com/user/repo
Username for 'https://github.com': your-username
Password for 'https://your-username@github.com': [paste-PAT-here]
```

**PAT Security:**
- ‚ö†Ô∏è **Never share your PAT**
- Treat it like a password
- Store securely (password manager recommended)
- Regenerate if compromised

### Chapter 03: Collaboration and Project Management

#### Using Other Repositories
**Cloning vs. Forking:**

**Cloning:**
- Similar to copy-paste but with a link to original repo
- Creates copy on local computer
- Linked to original repository
- Allows updates to go back and forth
- Use Git commands to push/pull changes
- Great for collaboration when you have access

**Forking:**
- Creates independent copy on GitHub
- No direct link to original repo
- Good for experimentation without risk
- Anyone can fork a public repo
- Submit changes via pull requests
- Different from creating branch (no collaborator access needed)

**Cloning Process:**
```bash
# Clone repository to local machine
git clone https://github.com/username/repository-name.git

# Example output
Cloning into 'repository-name'...
remote: Counting objects: 10, done.
remote: Compressing objects: 100% (8/8), done.
remote: Total 10 (delta 1), reused 10 (delta 1)
Unpacking objects: 100% (10/10), done.
```

**Forking Process:**
1. Navigate to repository you want to fork
2. Click "Fork" button (top right)
3. Choose where to fork (your account or organization)
4. Wait for GitHub to create the fork
5. Fork appears in your repositories

#### GitHub Issues
**What are Issues?**
- Messages to help track:
  - Problem fixes
  - Plans and roadmaps
  - Important tasks
  - Communications about the project

**Creating New Issues:**
1. Go to repository's "Issues" tab
2. Click "New issue"
3. Add title and description
4. Use markdown for formatting
5. Submit issue

**Managing Issues:**
**Assigning Issues:**
- Assignee: Who should work on the issue
- Can assign to collaborators
- Multiple people can be assigned

**Tagging in Issues:**
- Tag: Who needs to read/be notified about the issue
- Use @username to tag someone
- Tagged users receive notifications

**Issue Comments:**
- Add updates and discussion
- Reference other issues with #issue-number
- Quote previous comments using > symbol
- Support full markdown formatting

**Linking Issues:**
- Reference other issues: "Related to #123"
- Link to specific comments
- Create issue dependencies

**Closing Issues:**
- Click "Close issue" when resolved
- Add comment explaining resolution
- Closed issues remain accessible for reference

#### Pull Requests (PRs)
**What is a Pull Request?**
- Way to notify others about changes
- Allows repo owner to review changes before merging
- Best practice: create changes in separate branch (not main)
- Successful PR results in merging two branches

**Creating Pull Requests:**
1. Make changes in a branch (not main)
2. Navigate to repository
3. Click "Pull requests" tab
4. Click "New pull request"
5. Select branches to compare (base ‚Üê compare)
6. Review changes in diff view
7. Add title and description
8. Assign reviewers if needed
9. Create pull request

**Comparing Changes:**
- Shows differences between branches
- Green lines: additions
- Red lines: deletions
- File-by-file comparison
- Line-by-line changes highlighted

**PR Information:**
- Clear title describing changes
- Detailed description of what was changed
- Why changes were made
- Any testing performed
- Screenshots if UI changes

#### Reviewing Pull Requests
**Review Process Roles:**
- **Assignee**: Person who approves/merges the PR
- **Reviewer**: Person who examines changes before merge

**Requesting Reviews:**
1. In PR, click "Reviewers" section
2. Search for and select reviewers
3. Reviewers receive notification

**Conducting Reviews:**
1. Navigate to PR
2. Click "Files changed" tab
3. Review each changed file
4. Add comments on specific lines if needed
5. Submit review with decision

**Review Options:**
- **Comment**: Feedback and suggestions (no requirement to change)
- **Request Changes**: Feedback that must be incorporated before merge
- **Approve**: Changes look good and can be merged

**Adding Comments:**
- Click on line numbers to add inline comments
- General comments in conversation tab
- Use markdown for formatting
- Reference other issues/PRs with #number

**Responding to Reviews:**
- Address requested changes
- Make additional commits to same branch
- Reply to comments explaining changes
- Request re-review after making changes

**Merging Pull Requests:**
1. Ensure all reviews are approved
2. All checks pass (if configured)
3. Click "Merge pull request"
4. Choose merge type:
   - **Create merge commit**: Preserves branch history
   - **Squash and merge**: Combines commits into one
   - **Rebase and merge**: Replays commits without merge commit
5. Confirm merge

**Post-Merge Cleanup:**
- Delete feature branch (GitHub offers option)
- Branch can be restored if needed
- Closed PRs remain accessible for reference

**Restoring Deleted Branches:**
- Go to closed PR
- Click "Restore branch" if available
- Or create new branch from specific commit

---

## Course 4: Intermediate GitHub Concepts (Beginner) ‚úÖ

### Chapter 01: GitHub Projects and Automation

#### Introduction to GitHub Projects
**Definition and Benefits:**
- Organizes tasks and tracks progress
- Enhances collaboration between team members
- Simplifies project tracking and management

**Integration with Workflow:**
- Integrates seamlessly with issues and pull requests
- Provides centralized project management
- Offers customizable project boards

#### GitHub Projects vs Projects (Classic)
**GitHub Projects (New):**
- Flexible and highly customizable
- Independent of specific repositories
- Advanced features and better integration
- Modern interface with multiple view options

**Projects (Classic):**
- Tied directly to repositories
- Basic tracking capabilities
- Limited customization options

#### Setting Up GitHub Projects
**Project Creation Process:**
1. Navigate to GitHub and click "Projects"
2. Click "New project"
3. Choose project template or start from scratch
4. Configure project settings

**Available Layouts:**
- **Table Layout**: Spreadsheet-like view with columns and rows
- **Board Layout**: Kanban-style board with cards and columns
- **Roadmap Layout**: Timeline view for project planning
- **Other Layouts**: Additional specialized views

**Project Configuration:**
- **Project Name**: Descriptive name for easy identification
- **Description**: Clear project purpose and scope
- **Visibility Settings**: Public or private access
- **Adding Tasks**: Create and organize project items

#### Managing Project Visibility and Access
**Visibility Settings:**
- **Public**: Visible to everyone on the internet
- **Private**: Restricted to team members and collaborators only

**Access Roles:**
- **Admin**: Full control over project settings and content
  - Example: Head of data team, senior colleagues
- **Write**: Can modify project content and settings
  - Example: Data team members
- **Read**: View-only access to project information
  - Example: Product team members
- **No Access**: Complete restriction from project
  - Example: Other departments

#### Automation and Insights
**Importance of Automation:**
- **GitHub Actions**: Streamlines and automates workflows
- **Process Automation**: Simplifies repetitive tasks
- **Real-time Insights**: Provides progress tracking data
- **Issue Identification**: Helps spot bottlenecks early
- **Informed Decisions**: Data-driven project management

**Automation Tools:**
**Built-in Automations:**
- Auto-move tasks based on specific events
- Keep project boards updated automatically
- Trigger actions when issues/PRs change status

**GitHub Actions Integration:**
- Automate complex workflows using YAML files
- Tag and manage tasks efficiently
- Trigger tasks based on code events
- Example workflow for data analysis:
```yaml
name: Data Workflow
on: [push]
jobs:
  run-analysis:
    runs-on: ubuntu-latest
    steps:
    - uses: actions/checkout@v4
    - name: Run analysis
      run: python analyze_data.py
```

#### Project Insights
**Insight Capabilities:**
- **Progress Visualization**: Real-time and historical data charts
- **Bottleneck Detection**: Identify issues early in development
- **Chart Types**: Both current status and historical trend charts
- **Data Analysis**: Track project performance over time

**Creating Charts:**
- Access project insights section
- Choose appropriate chart type
- Configure data parameters
- Save and share insights with team

### Chapter 02: GitHub Administration and Authentication

#### GitHub Organizations
**What is a GitHub Organization?**
- **Centralized Workspace**: Manage multiple projects under one umbrella
- **Role-based Access**: Control permissions at different levels
- **Security Policies**: Implement organization-wide security measures
- **Team Management**: Organize users into teams with specific roles

**Creating Organizations:**
- Navigate to GitHub and click "New organization"
- Choose organization name and contact email
- Configure billing settings
- Set up initial teams and repositories

#### Organization Administration
**Key Organization Roles:**
- **Owner**: Full control over the entire organization
  - Manage all settings and permissions
  - Add/remove members and teams
  - Access billing and security settings
- **Member**: Standard access for day-to-day collaboration
  - Access to organization repositories
  - Can create repositories (if permitted)
- **Outside Collaborator**: Limited access to specific repositories
  - No organization-level permissions
  - Repository-specific access only

**Additional Specialized Roles:**
- **Moderator**: Manages interactions in public repositories
  - Can block users and hide comments
  - Helps maintain community standards
- **Billing Manager**: Handles organization billing settings
  - Access to payment information
  - Can modify subscription plans
- **Security Manager**: Oversees organization security settings
  - Manages security policies
  - Reviews security alerts

#### Team Management
**Why Use Teams?**
- Simplifies permission management
- Organizes members by projects, roles, or departments
- Enables bulk permission assignments
- Facilitates communication and collaboration

**Team Creation:**
- **Who Can Create**: Organization owners and members (if permitted)
- **Organization Structure**: Group by projects, roles, or departments
- **Nested Teams**: Create hierarchical team structures reflecting internal organization

**Team Administration Roles:**
- **Team Member**: Collaborates on assigned projects
- **Team Maintainer**: Manages team settings and membership
  - Can add/remove team members
  - Modify team settings and permissions

**Best Practice:**
- Assign permissions to teams rather than individuals
- Makes management easier and more scalable
- Ensures consistent access control

#### Repository-Level Administration
**Repository Permission Levels:**
- **Read**: View repository contents and participate in discussions
- **Triage**: Manage issues and pull requests without write access
- **Write**: Push code changes to repository
- **Maintain**: Manage repository settings without access to sensitive actions
- **Admin**: Full control over repository including sensitive settings

#### Authentication Methods
**Available Authentication Options:**
- **Two-Factor Authentication (2FA)**: Adds extra security layer
- **SSH Keys**: Secure, key-based authentication
- **Personal Access Tokens (PAT)**: Controlled API access
- **Identity Providers (IdP)**: Centralized user management

#### Two-Factor Authentication (2FA)
**2FA Methods:**
- **Security Keys**: Most secure option using hardware keys
- **TOTP (Time-based One-Time Password)**: Codes via authentication apps
- **SMS Codes**: Receive verification codes via text message
- **GitHub Mobile**: Convenient mobile app authentication

**Setting Up 2FA:**
1. Go to GitHub Settings > Password and authentication
2. Click "Enable two-factor authentication"
3. Choose preferred 2FA method
4. Follow setup instructions
5. Save recovery codes securely

**Enabling 2FA for Organizations:**
- Organization owners can require 2FA for all members
- Set up in organization settings
- Members receive notification to enable 2FA
- Non-compliant members lose organization access

#### SAML Single Sign-On (SSO)
**Understanding SAML SSO:**
- **Single Sign-On**: One secure login for multiple applications
- **Requirements**: Requires SAML Identity Provider setup
- **Common IdPs**: Microsoft Entra ID, Okta, OneLogin
- **Benefits**: Centralized authentication and improved security

**SAML SSO Implementation:**
- Available for GitHub Enterprise Cloud
- Requires organization owner permissions
- Configuration through identity provider
- Users authenticate through corporate SSO

#### Personal Access Tokens (PAT)
**PAT Overview:**
- **Purpose**: Secure codes replacing passwords for API access
- **Use Cases**: 
  - Automating tasks and workflows
  - Integrating with development tools
  - Accessing GitHub from scripts and applications

**PAT Types:**
- **Classic PATs**: Broad access scope, less granular control
- **Fine-grained PATs**: Precise permission control, enhanced security
  - Repository-specific access
  - Limited scope and duration
  - Better security practices

**Creating PATs:**
1. Go to GitHub Settings > Developer settings
2. Click "Personal access tokens"
3. Choose token type (Classic or Fine-grained)
4. Set expiration date
5. Select required scopes/permissions
6. Generate and securely store token

#### OAuth Authorization Model
**OAuth Benefits:**
- **Secure Access**: Provides limited, controlled access to applications
- **Credential Protection**: Safeguards user credentials
- **Third-party Integration**: Enables secure app connections
- **Use Case Example**: Connecting data tools like Apache Airflow to GitHub

### Chapter 03: Team Synchronization and Secure Access Strategy

#### Team Synchronization
**Understanding Team Synchronization:**
- **Automation**: Links GitHub teams to Identity Provider (IdP) groups
- **Automatic Updates**: Syncs team membership with corporate directory
- **Efficiency**: Reduces manual administrative work
- **Requirements**: GitHub Enterprise Cloud and compatible IdP (e.g., Okta)

**Team Synchronization Benefits:**
- **Enhanced Security**: Automatically adjusts access based on IdP changes
- **Scalability**: Manages large teams without manual intervention
- **Operational Efficiency**: Automates routine access management tasks
- **Consistency**: Ensures GitHub access matches organizational structure

**Setting Up Team Synchronization:**
1. Configure SAML SSO for organization
2. Set up team synchronization in organization settings
3. Map GitHub teams to IdP groups
4. Test synchronization process
5. Monitor ongoing synchronization

#### Employee Lifecycle Management
**Onboarding Process (Example: Emily):**
**Step 1: Initial Setup**
- Invite Emily to join the organization
- Assign Member role for standard access
- Request 2FA setup for security compliance

**Step 2: Identity Provider Integration**
- Add Emily to appropriate group in IdP (e.g., "Data Team")
- Automatic synchronization adds her to GitHub "Data Team"
- Receives write access to relevant repositories (e.g., ecommerce-data-hub)

**Step 3: Daily Workflow Setup**
- Emily generates Personal Access Token (PAT)
- Integrates GitHub repository with development tools
- Performs daily tasks: code development, commits, and pushes

**Offboarding Process:**
- Remove employee from IdP groups
- GitHub access automatically revoked through synchronization
- Review and archive employee contributions
- Secure handover of responsibilities

#### InnerSource Program Management
**Transitioning from Open Source to InnerSource:**
- **Open Source Projects**: Publicly available code with global collaboration
- **InnerSource**: Applies open-source practices within organization
- **Benefits**: Enhanced internal collaboration and transparency
- **Controlled Environment**: Maintains security while promoting openness

#### InnerSource Overview
**Core Principles:**
- Apply open-source development practices internally
- Promote transparency and collaboration across teams
- Encourage shared ownership of code and projects
- Standardize contribution processes with templates

**Implementation Strategy:**
- Convert appropriate repositories to internal visibility
- Establish contribution guidelines and templates
- Create clear documentation and onboarding processes
- Foster culture of internal collaboration

#### Internal Repositories
**Repository Visibility Types:**
- **Private**: Access limited to specified collaborators
- **Public**: Visible to everyone on the internet
- **Internal**: Automatic read access for all organization members

**Converting to Internal Repository:**
1. Navigate to repository settings
2. Go to "Danger Zone" section
3. Click "Change repository visibility"
4. Select "Make internal"
5. Confirm changes

#### Repository Templates and Standards
**Creating Effective Repository Structure:**
- **Clear Titles**: Use descriptive names (e.g., "data-pipelines", "ml-models")
- **Consistent Naming**: Follow organization naming conventions
- **Comprehensive Documentation**: Include setup and usage instructions

**Issue and PR Templates:**
**Issue Templates:**
- Standardize problem reporting
- Include required information fields
- Provide clear submission guidelines
- Ensure consistent issue quality

**Pull Request Templates:**
- Guide contributors on change submission
- Include checklist for reviewers
- Standardize change documentation
- Improve code review process

**Creating Templates:**
1. Navigate to repository settings
2. Click "Set up templates" in Features section
3. Create issue template or PR template
4. Define template structure and required fields
5. Save and test templates

#### InnerSource Limitations and Challenges
**Common Challenges:**
- **Cultural Resistance**: Teams may prefer traditional development methods
- **Security Concerns**: Risk of exposing sensitive information
- **Governance Requirements**: Need for strong policies and oversight
- **Resource Investment**: Requires additional training and support resources

**Mitigation Strategies:**
- Gradual implementation and change management
- Clear security guidelines and training
- Executive sponsorship and support
- Regular program evaluation and improvement

### Chapter 04: Security and Secure Development Strategy

#### Importance of Secure Development
**Why Security Matters:**
- **Code Protection**: Essential for maintaining project integrity
- **Automated Security**: Reduces manual security review workload
- **Early Prevention**: Identifies and fixes vulnerabilities before deployment
- **Compliance**: Meets organizational and regulatory security requirements

#### GitHub Advanced Security Features
**Core Security Tools:**
- **Code Scanning**: Automatically identifies vulnerabilities in source code
- **Secret Scanning**: Detects and protects sensitive data like API keys
- **Dependency Graph**: Visualizes project dependencies and relationships
- **Dependabot**: Manages dependencies and automates security updates

**Security Integration:**
- Available for GitHub Enterprise Cloud
- Integrates with existing development workflows
- Provides actionable security insights
- Supports multiple programming languages

#### Dependency Management
**Understanding Dependency Graph:**
- **Visualization**: See all project dependencies in one view
- **Risk Assessment**: Identify vulnerabilities in dependency chain
- **Update Tracking**: Monitor changes and updates to dependencies
- **Security Monitoring**: Track security advisories for dependencies

**Adding Dependencies:**
**Python Project Example:**
```python
# requirements-analysis.txt
pandas==1.2.4
numpy==1.20.3
matplotlib==3.4.2

# requirements-ml.txt
pandas==1.3.0
numpy==1.21.0
scikit-learn==0.24.2

# setup.py
name="ecommerce-data-hub",
version="0.1",
packages=find_packages(),
```

**Viewing Dependency Graph:**
1. Navigate to repository
2. Click "Insights" tab
3. Select "Dependency graph"
4. Review dependencies and their relationships
5. Check for security advisories

#### Dependabot Configuration
**Enabling Dependabot Alerts:**
1. Go to repository Settings
2. Navigate to "Security & analysis" section
3. Enable "Dependabot alerts"
4. Configure notification preferences
5. Review generated alerts

**Managing Dependabot Alerts:**
- **Alert Review**: Check security tab for vulnerabilities
- **Priority Assessment**: Evaluate severity and impact
- **Automated Updates**: Allow Dependabot to create fix PRs
- **Manual Review**: Review and merge security updates

**Dependabot Workflow:**
1. **Dependency Graph**: Visualizes all dependencies
2. **Dependabot Alerts**: Notifies about vulnerabilities
3. **Dependabot Updates**: Automatically creates fix PRs
4. **Review Process**: Team reviews and merges updates

#### Security Policies and Data Management
**Security Policy Setup:**
**SECURITY.md File:**
- **Purpose**: Provides guidelines for security issue reporting
- **Key Elements**: 
  - Contact information for security team
  - Reporting guidelines and procedures
  - Expected response times
  - Disclosure policies
- **Customization**: Tailored to project-specific security needs

**Creating SECURITY.md:**
1. Create new file named "SECURITY.md" in repository root
2. Include security reporting procedures
3. Provide contact information
4. Define response timelines
5. Commit and make visible to contributors

#### Sensitive Data Management
**Risks of Committing Sensitive Data:**
- **Data Exposure**: Risk of leaking confidential information
- **Unauthorized Access**: Potential system compromise
- **Compliance Violations**: Regulatory and legal issues
- **Immediate Action Required**: Quick response needed to minimize damage

**If Sensitive Data is Committed:**
1. **Change credentials immediately** if API keys or passwords were exposed
2. **Assess exposure scope** and potential impact
3. **Remove sensitive data** from repository history
4. **Notify relevant stakeholders** about the incident

**Data Removal Tools:**
**git filter-repo:**
- **Detailed Control**: Comprehensive history management
- **Complex Operations**: Best for intricate cleanup scenarios
- **Versatile**: Supports various repository manipulation tasks

**BFG Repo-Cleaner:**
- **Fast Processing**: Quick and simple to use
- **Bulk Operations**: Excellent for large-scale deletions
- **Open Source**: Focused on speed and efficiency

**Important Note:**
- GitHub UI has limitations for advanced repository cleanup
- Terminal commands required for sensitive data removal
- Always backup repository before major cleanup operations
- Consider professional security consultation for serious breaches

**Cleanup Process Overview:**
1. **Immediate Response**: Change exposed credentials
2. **Tool Selection**: Choose appropriate cleanup tool
3. **Backup Creation**: Ensure repository backup exists
4. **Cleanup Execution**: Remove sensitive data from history
5. **Force Push**: Update remote repository
6. **Team Notification**: Inform team about changes
7. **Monitoring**: Watch for any remaining exposure

---

## 5. Advanced Git

### Chapter 1: Understanding Merge Types

**Merge Strategies:**
- **Fast-forward merge**: Keeps simple, linear history; ideal for short-lived branches
  ```bash
  git merge feature_branch
  git merge --ff-only feature_branch  # Force fast-forward
  ```

- **Recursive merge**: Creates merge commit with two parents; preserves project history
  ```bash
  git merge --no-ff feature_branch
  ```

**Complex Merge Scenarios:**
- **Squash merge**: Combines multiple commits into single commit for clean history
  ```bash
  git merge --squash source_branch
  git commit -m "Implement feature"
  ```

- **Octopus merge**: Merges three or more branches simultaneously
  ```bash
  git merge -s octopus branch1 branch2 branch3
  ```

**Git Rebasing:**
- **Basic rebase**: Maintains linear commit history by replaying commits
  ```bash
  git checkout feature_branch
  git rebase main
  ```

- **Interactive rebase**: Allows granular changes to commit history
  ```bash
  git rebase -i HEAD~3  # Edit last 3 commits
  ```

**Key Principles:**
- Use merge for preserving development context
- Use rebase for clean, linear history
- Never rebase public branches
- Interactive rebase useful for cleaning up before merging

### Chapter 2: Advanced Git Operations

**Cherry-Picking:**
- Apply specific commits to another branch
  ```bash
  git cherry-pick <commit-hash>
  git cherry-pick <hash1> <hash2>  # Multiple commits
  ```

- **Conflict resolution:**
  ```bash
  git cherry-pick --continue  # After resolving conflicts
  git cherry-pick --abort     # Cancel operation
  ```

**Git Bisect:**
- Binary search to find bug-introducing commit
  ```bash
  git bisect start
  git bisect bad              # Mark current as bad
  git bisect good <commit>    # Mark known good commit
  git bisect run <script>     # Automated testing
  git bisect reset           # Exit bisect mode
  ```

**Git Filter-Repo:**
- Rewrite repository history safely
  ```bash
  pip install git-filter-repo
  git filter-repo --path secrets.txt --invert-paths  # Remove file from history
  ```

**Git Reflog:**
- Local record of ALL reference updates
  ```bash
  git reflog                    # View reflog
  git reflog --since="1 week ago"  # Filtered view
  ```

- **Recovery operations:**
  ```bash
  git checkout <hash>          # Move to specific commit
  git checkout -b new-branch   # Create branch from current HEAD
  git reset --soft HEAD@{1}    # Soft reset to previous state
  ```

**Reset Types:**
- `--soft`: Keeps changes staged
- `--mixed`: Unstages changes (default)
- `--hard`: Discards all changes

### Chapter 3: Advanced Workflow Management

**Git Worktrees:**
- Multiple active branches in separate directories
  ```bash
  git worktree add <path> <branch>     # Create worktree
  git worktree list                    # List worktrees
  git worktree remove <path>           # Remove worktree
  ```

**Git Submodules:**
- Nested repositories with separate version control
  ```bash
  git submodule add <repo-url> <path>          # Add submodule
  git submodule status                         # List submodules
  git submodule update --init --remote         # Update submodules
  git submodule deinit <name>                  # Remove submodule
  ```

**Git Large File Storage (LFS):**
- Manage large files efficiently
  ```bash
  git lfs install                      # Initialize LFS
  git lfs track "*.csv"               # Track file types
  git add .gitattributes              # Add tracking config
  git lfs pull                        # Download LFS content
  ```

**Trunk Based Development:**
- **Core principles:**
  - Frequent commits to main branch
  - Short-lived feature branches (< 1 day)
  - Continuous integration
  - Feature flags for incomplete work

- **Benefits:**
  - Reduced merge conflicts
  - Faster release cycles
  - Improved code quality
  - Better collaboration

- **Best practices:**
  - Commit small changes frequently
  - Automate testing and deployment
  - Use feature flags strategically
  - Conduct regular code reviews

**Key Takeaways:**
- Master advanced merge strategies for different scenarios
- Use bisect for efficient debugging
- Leverage worktrees for parallel development
- Implement proper large file management
- Adopt trunk-based development for faster delivery

---

## Quick Reference Guide

### Most Used Commands
```bash
# Status and Info
git status
git log
git log --oneline
git branch
git remote -v

# Basic Workflow
git add .
git commit -m "message"
git diff
git diff branch1 branch2

# Branch Operations
git switch branch-name
git switch -c new-branch
git merge source-branch
git branch -d branch-name

# Remote Operations
git clone URL
git pull origin
git push origin branch-name
git fetch origin

# Undoing Changes
git restore --staged filename
git checkout HEAD~1 -- filename
git revert HEAD
```

### Common Git Patterns
- Always check `git status` before committing
- Use descriptive commit messages
- Stage related changes together
- Review changes with `git diff` before committing
- **Pull before pushing** to avoid conflicts
- **Create branches for features** and bug fixes
- **Delete branches** after merging to keep repo clean
- **Commit local changes** before pulling from remote

---

## Learning Progress Tracker

- [x] **Introduction to Git**: Basic commands, staging, committing, history
- [x] **Intermediate Git**: Branches, merging, conflicts, remotes, push/pull workflow
- [x] **GitHub Concepts**: Repository management, README creation, branches, collaboration, issues, pull requests  
- [x] **Intermediate GitHub**: Projects, administration, authentication, InnerSource, security
- [x] **Advanced Git**: Merge strategies, rebasing, cherry-picking, bisect, filter-repo, reflog, worktrees, submodules, LFS, trunk-based development

---

*Last Updated: Saturday, July 08, 2025*
*Course Progress: 5/5 courses completed*